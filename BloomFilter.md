# BloomFilter

## 布隆过滤器

布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。（From wiki）

## 原理

布隆过滤器的原理是，当一个元素被加入集合时，通过K个[散列函数](https://zh.wikipedia.org/wiki/散列函数)将这个元素映射成一个位[数组](https://zh.wikipedia.org/wiki/数组)中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。(From wiki)

## 优点

判断一个元素是否在一个集合中，一般是想到将所有元素保存起来，然后通过比较确认。链表、树、散列表都是这种思路，但是随着元素集合的增加需要的储存空间会越来越大，同时影响检索速度，以上三种结构的时间复杂度分别是O(n)、O(logn)、O(1)。

而布隆过滤器相较其他的数据结构，在空间和时间方面都有很大的优势；

储存空间和插入/查询的时间复杂度都是常数O(k),另外散列函数之间没有关联，可以有硬件并行实现以减少时间消耗。其次布隆过滤器本身不需要储存元素本身，只需要对元素是否存在加以验证，在某些对保密要求高的场合有优势。

布隆过滤器可以表示全集，其他任何数据结构都不能；

## 缺点

但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。

另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。

在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。

## 使用场景

1. 判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。
2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。